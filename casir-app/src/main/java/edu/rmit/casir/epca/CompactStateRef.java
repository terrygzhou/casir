package edu.rmit.casir.epca;

import java.io.PrintStream;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.Vector;

import lts.ActionName;
import lts.CompactState;
import lts.EventState;
import lts.LTSException;
import lts.Pair;
import lts.Transition;
import org.apache.log4j.Logger;

import api.APITest;
import edu.rmit.casir.util.DistributedRandomNumberGenerator;
import edu.rmit.casir.util.GeneralUtil;

/**
 * The Class CompactStateRef reflects to the CompactState i.e. the impl of PCA.
 */
public class CompactStateRef {

	// The pca obj reflected from CompactState
	CompactState pcaObj;

	String name;

	// The compact state clazz.
	Class compactStateClazz;

	// The ext lts.
	// SortedMap<String, Set<ExtTransition>> extLTS;

	static Logger logger = Logger.getLogger(CompactStateRef.class);

	// ************************** Methods **********************************

	/**
	 * Instantiates a new compact state ref.
	 * 
	 * @param compactState
	 *            the compact state
	 */
	public CompactStateRef(CompactState compactState) {
		this.pcaObj = compactState;
		/**
		 * placeholder to create state labels
		 */
		// explore the pcaObject against the its abstract states

		try {
			this.compactStateClazz = Class.forName("lts.CompositeState");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Checks if is output action.
	 *
	 * @param stateID
	 *            the state id
	 * @param action
	 *            the action
	 * @return true, if is output action
	 */
	private boolean isOutputAction(String stateID, String action) {
		for (int i = 0; i < pcaObj.maxStates; ++i) {
			EventState current = pcaObj.states[i];
			while (current != null) {
				ActionName label = current.getEventPCA();
				if (action.equals(label.getLabel()))
					return true;
				current = current.getList();
			}
		}
		return false;
	}

	/**
	 * Gets the private object.
	 *
	 * @param fieldName
	 *            the field name
	 * @return the private object
	 */
	public Object getPrivateObject(String fieldName) {
		Field f = null;
		try {
			f = this.pcaObj.getClass().getDeclaredField(fieldName);
			f.setAccessible(true);
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		}
		try {
			return f.get(this.pcaObj);
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * Go thru the state transition of the given compactState.
	 * 
	 * Identified the bug/inconsistency between lts generated by EventState[] method
	 * and the lts generated by successor method. the latter is used in DTMC
	 * generation
	 * 
	 * @return
	 */
	public Map<Integer, Set<Transition>> getLTS() {

		Map<Integer, Pair<Set<Transition>, Boolean>> succ = (Map<Integer, Pair<Set<Transition>, Boolean>>) this
				.getPrivateObject("successors");
		Map<Integer, Set<Transition>> lts = new HashMap<Integer, Set<Transition>>();

		for (int currentState : succ.keySet()) {
			Pair<Set<Transition>, Boolean> fromStateObj = succ.get(currentState);
//			logger.debug("current state " + currentState);
//			logger.debug("outTrans are ");
			Set<Transition> outTrans = fromStateObj.getFirst();

			// Debugging...
//			for (Transition t : outTrans) {
//				logger.debug("Type: " + t.getEventPCA().getTypeString());
//				if (t.getEventPCA().toString().contains("~")) {
//					logger.debug("ERROR state");
//				}
//				logger.debug("<" + t.getEventPCA().getProbability() + "> "
//						+ t.getEventPCA().getOriginalLabel() + "\t targetState " + t.getTo());
//			}
//			logger.debug("\n");

			// v.getFirst().forEach(t ->
			// logger.debug("<"+t.getEventPCA().getProbability()+"> "+
			// t.getEventPCA().getOriginalLabel()));

			// lts.put(currentState, fromStateObj.getFirst());
			lts.put(currentState, outTrans);

			// Set<Transition> succs = fromStateObj.getFirst();
			for (Transition successor : outTrans) {
				/**
				 * for deadlock states
				 */
				// if ((succ.get(Integer.valueOf(successor.getTo())) != null)
				// || (successor.getTo() == -1))
				// mistake of including the ERROR state accidently
				if ((succ.get(Integer.valueOf(successor.getTo())) != null))
					continue;
				// for ERROR state
				if (successor.getEventPCA().toString().contains("~")) {
					lts.put(-1, new HashSet<>());
//					logger.debug("ERROR state");
					continue;
				}
				// ((Set) deadlockStates).add(Integer.valueOf(successor.getTo()));
				// otherwise, the deadlock states are pushed in
				lts.put(successor.getTo(), new HashSet<>());
			}
		}
		return lts;
	}

	/**
	 * output the lts represented in Dot file for debugging
	 * 
	 * @return
	 */
	public String convertToGraphviz() {
		StringBuilder graphvizSpecification = new StringBuilder();

		graphvizSpecification.append("digraph " + this.getPcaObj().name.toUpperCase() + " {\n"
				+ "\t rankdir = LR;\n"
				+ "\t graph [fontname = \"monospace\", ranksep=\"0.2\", nodesep=\"0.1\"]; \n"
				+ "\t node [fontname = \"monospace\"]; \n"
				+ "\t edge [fontname = \"monospace\"]; \n");

		int nStates = this.getPcaObj().maxStates;

		boolean hasFailureAction = false;

		graphvizSpecification.append(
				"\t 0 [shape = circle, color = black, style = filled, fillcolor = red]; \n");
		for (int i = 1; i < nStates; ++i) {
			graphvizSpecification.append("\t " + i
					+ " [shape = circle, color = black, style = filled, fillcolor = cyan]; \n");
		}

		// Iterator localIterator1 = this.successors.entrySet().iterator();
		if (this.getLTS() == null)
			logger.fatal("run the unfolding first");
		Iterator localIterator1 = this.getLTS().entrySet().iterator();
		for (int i : this.getLTS().keySet()) {
			int currentstate = i;
			Set<Transition> currentStateSuccessors = this.getLTS().get(i);
			for (Transition successor : currentStateSuccessors) {
				int destinationState = successor.getTo();
				ActionName label = successor.getEventPCA();

				graphvizSpecification.append("\t " + currentstate + " -> " + destinationState
						+ "[label = \"" + label.getOriginalLabel() + "\" ];\n");

				if (label.isFailureAction()) {
					hasFailureAction = true;
				}

			}
		}

		// while (localIterator1.hasNext()) {
		// Map.Entry stateSuccInfo = (Map.Entry) localIterator1.next();
		// int currentstate = ((Integer) stateSuccInfo.getKey()).intValue();
		// Set<Transition> currentStateSuccessors = (Set) stateSuccInfo.getValue();
		//
		// for (Transition successor : currentStateSuccessors) {
		// int destinationState = successor.getTo();
		// ActionName label = successor.getEventPCA();
		//
		// graphvizSpecification.append("\t " + currentstate + " -> " + destinationState
		// + "[label = \"" + label.getOriginalLabel() + "\" ];\n");
		//
		// if (label.isFailureAction()) {
		// hasFailureAction = true;
		// }
		// }
		// }

		if (hasFailureAction) {
			graphvizSpecification.append(
					"\t -1 [shape = circle, color = black, style = filled, fillcolor = red]; \n");
		}
		graphvizSpecification.append("}\n");

		return graphvizSpecification.toString();

	}

	/**
	 * Replacing all "successor" based approach with EventState[] approach to
	 * generate LTS
	 * 
	 * @deprecated
	 * @return <stateID, Set<outTransition>>
	 */
	public Map<Integer, Set<Transition>> outputLTS2() {
		CompactState pca = this.getPcaObj();

		Map<Integer, Set<Transition>> container = new HashMap<>();

		EventState[] stateArr = pca.states;

		for (int i = 0; i < pca.maxStates; ++i) {

			EventState current = pca.states[i];
			Set<Transition> outTrans = container.get(i);
			if (outTrans == null) {
				outTrans = new HashSet<>();
				container.put(i, outTrans);
			}

			if (current == null) {

				// if (i == pca.getEndseq())
				// output.print("END");
				//
				// else
				// output.print("STOP");
			} else {
				while (current != null) {
					Transition t;
					ActionName label = current.getEventPCA();

					logger.debug(label.getTypeString() + "<" + label.getProbability() + "> "
							+ label.getLabel() + " -> ");

					t = new Transition(i, label, current.getNext());
					outTrans.add(t);
					current = current.getList();
				}
			}
		}

		/**
		 * testing container
		 */
		container.forEach((k, v) -> {
			logger.debug(k);
			v.forEach(tran -> {
				logger.debug(tran.getFrom() + " : " + tran.getLabel() + " : " + tran.getTo());
			});
		});
		return container;
	}

	/**
	 * Comparing between the LTS generated by Successor and EventState[] approaches
	 * provided by PCA
	 */
	public void compareLTSCorrect() {
		Map<Integer, Set<Transition>> lts = this.getLTS();
		Map<Integer, Set<Transition>> lts2 = this.outputLTS2();
		logger.info(lts);
		logger.info(lts2);
		if (lts.keySet().size() != lts2.keySet().size()) {
			logger.fatal("States size is different!!!");
			logger.info(lts.keySet().size());
			lts.keySet().forEach(k1 -> {
				logger.info(k1);
			});
			logger.info(lts2.keySet().size());
			lts2.keySet().forEach(k2 -> {
				logger.info(k2);
			});
		} else
			lts.forEach((stateId, trans) -> {
				logger.info("state ID: " + stateId);
				// ***********
				String outTransStr = "";
				for (Transition t : trans) {
					outTransStr = outTransStr + t.getLabel() + "\t";
				}
				logger.info("outgoing transitions of LTS1: " + outTransStr);

				// ***************
				outTransStr = "";
				Set<Transition> trans2 = lts2.get(stateId);
				for (Transition t : trans2) {
					outTransStr = outTransStr + t.getLabel() + "\t";
				}
				logger.info("outgoing transitions of LTS2: " + outTransStr);
			});
	}

	/**
	 * To create a DTMC Prism for the EPCA-unfolding composite PCA models, given a
	 * composed CompactState Object in which the transitions' labels carry all
	 * variables,.
	 *
	 * @return the string
	 * @throws LTSException
	 *             the LTS exception
	 */
	public String convertPCAToDTMC() throws LTSException {
		logger.info("THIS FIX THE PROBABILITY DOUBLE TYPE ISSUE");
		String name = (String) this.getPrivateObject("name");
		Set<String> failureActions = this.pcaObj.getFailureActions();
		Set<String> outputFailureActions = this.pcaObj.getOutputFailureActions();
		Set<String> inputActions = this.pcaObj.getInputActions();
		Set<String> internalFailureActions = this.pcaObj.getInternalFailureActions();

		int maxStates = (Integer) this.getPrivateObject("maxStates");

		if (inputActions.size() > 0) {
			throw new LTSException(
					"Process " + name + " cannot be analysed since it is not a closed PCA");
		}

		StringBuilder prismModel = new StringBuilder();

		prismModel.append("dtmc\n\n");
		prismModel.append("module " + name.toLowerCase() + " \n\n");

		int nStates = (failureActions.size() == 0) ? maxStates - 1 : maxStates;
		prismModel.append("\ts: [0.." + nStates + "] init 0;\n");
		prismModel.append("\tfinish: bool init false;\n");

		/**
		 * declare all internal variables of the composite process
		 */
		// for (String failureActionLabel : outputFailureActions) {
		// prismModel.append("\t" + failureActionLabel + " : bool init false;\n");
		// }
		outputFailureActions
				.forEach(label -> prismModel.append("\t" + label + " : bool init false;\n"));

		// for (String failureActionLabel : internalFailureActions) {
		// prismModel.append("\t" + failureActionLabel + " : bool init false;\n");
		// }
		internalFailureActions
				.forEach(label -> prismModel.append("\t" + label + " : bool init false;\n"));
		prismModel.append("\n");

		boolean hasFailureAction = false;
		Object deadlockStates = new HashSet();

		Map<Integer, Pair<Set<Transition>, Boolean>> successors = (Map<Integer, Pair<Set<Transition>, Boolean>>) this
				.getPrivateObject("successors");
		// logger.info(successors);
		Iterator localIterator2 = successors.entrySet().iterator();
		int currentstate;

		while (localIterator2.hasNext()) { // for each global state
			Map.Entry stateSuccInfo = (Map.Entry) localIterator2.next();
			currentstate = ((Integer) stateSuccInfo.getKey()).intValue();
			Set<Transition> currentStateSuccessors = (Set) ((Pair) stateSuccInfo.getValue())
					.getFirst();

			double totalProbability = 0.0D;
			for (Transition successor : currentStateSuccessors) {
				totalProbability += successor.getEventPCA().getProbability();
			}
			prismModel.append("\t[] s = " + currentstate + " -> ");
			int succ = 0;

			StringBuilder comments = new StringBuilder("\n \t// ");

			for (Transition successor : currentStateSuccessors) {
				// logger.info("TMD....... "+successor.getTo());
				++succ;
				ActionName successorLabel = successor.getEventPCA();

				successorLabel.setProbability(successorLabel.getProbability() / totalProbability);

				int destinationState = (successor.getTo() == -1) ? maxStates : successor.getTo();
				prismModel.append(GeneralUtil.round(successor.getEventPCA().getProbability(), 4)
						+ ":(s' = " + destinationState + ")");

				comments.append(GeneralUtil.round(successor.getEventPCA().getProbability(), 4)
						+ ":(" + successor.getEventPCA().getLabel() + " = " + destinationState
						+ ")");

				/**
				 * update the variables' values based on the toState's local values; if the
				 * transition is an internal transition from a process P,
				 */

				if (successorLabel.isFailureAction()) {
					prismModel.append("&(" + successorLabel.getLabel() + "'=true)");
					hasFailureAction = true;
				} else if ((successor.getTo() == 0) || ((successor.getTo() != -1)
						&& (successors.get(Integer.valueOf(successor.getTo())) == null))) {
					prismModel.append("&(finish'=true)");
				}

				String transitionLabel = successor.getLabel();

				if (succ < currentStateSuccessors.size()) {
					prismModel.append(" + ");
					comments.append(" + ");
				}

				if ((successors.get(Integer.valueOf(successor.getTo())) != null)
						|| (successor.getTo() == -1))
					continue;
				((Set) deadlockStates).add(Integer.valueOf(successor.getTo()));
			}
			prismModel.append("; " + comments.toString() + "\n");
		}

		if (hasFailureAction)
			prismModel.append("\t[] s = " + maxStates + " -> 1:(s' = " + maxStates + ");\n");
		for (Integer deadlockState : (Set<Integer>) deadlockStates) {
			prismModel.append("\t[] s = " + deadlockState + " -> 1:(s' = " + deadlockState
					+ "); // deadlock state \n");
		}

		prismModel.append("\nendmodule\n\n");
		if (hasFailureAction) {
			prismModel.append("label \"failure\" = ");
		}
		Iterator outputFailureActionsIterator = outputFailureActions.iterator();
		if (outputFailureActionsIterator.hasNext()) {
			prismModel.append((String) outputFailureActionsIterator.next());
		}
		while (outputFailureActionsIterator.hasNext()) {
			prismModel.append(" | " + ((String) outputFailureActionsIterator.next()));
		}
		for (String failureActionLabel : internalFailureActions) {
			prismModel.append(" | " + failureActionLabel);
		}
		prismModel.append("; \n");

		return prismModel.toString();
	}

	/**
	 * Get output transition from a given stateID.
	 *
	 * @param sourceID
	 *            the source id
	 * @deprecated
	 * @return the output trans from source state
	 */
	public Set<Transition> getOutTransFromState(int sourceID) {
		Set<Transition> outTrans = new HashSet<>();
		Map<Integer, Pair<Set<Transition>, Boolean>> successors = (Map<Integer, Pair<Set<Transition>, Boolean>>) this
				.getPrivateObject("successors");
		// logger.info(successors);
		Iterator localIterator2 = successors.entrySet().iterator();
		int currentstate;
		while (localIterator2.hasNext()) { // for each global state
			Map.Entry stateSuccInfo = (Map.Entry) localIterator2.next();
			currentstate = ((Integer) stateSuccInfo.getKey()).intValue();
			if (currentstate == sourceID) {
				Set<Transition> currentStateSuccessors = (Set) ((Pair) stateSuccInfo.getValue())
						.getFirst();
				// double totalProbability = 0.0D;
				for (Transition successor : currentStateSuccessors) {
					// totalProbability +=
					// successor.getEventPCA().getProbability();
					outTrans.add(successor);
				} // for
				break;
			} // if (currentstate==sourceID)
		} // while
		return outTrans;
	}

	/**
	 * given a source state ID, return a set of outgoing transitions
	 * 
	 * @param sourceID
	 * @return
	 */
	public Set<Transition> getOutTransFromState2(int sourceID) {
		return this.getLTS().get(sourceID);
	}

	/**
	 * Prints the pca.
	 *
	 * @param pca
	 *            the pca
	 */
	public static void printPCA(CompactState pca) {
		PrintStream output = System.out;
		output.println("Process:");
		output.println("\t" + pca.name);

		output.println("States:");
		output.println("\t" + pca.maxStates);
		output.println("Transitions:");
		output.println("\t" + pca.name + " = Q0,");
		int linecount = 0;
		for (int i = 0; i < pca.maxStates; ++i) {
			output.print("\tQ" + i + "\t= ");
			EventState current = pca.states[i];
			if (current == null) {
				if (i == pca.getEndseq())
					output.print("END");
				else
					output.print("STOP");
				if (i < pca.maxStates - 1)
					output.println(",");
				else
					output.println(".");
			} else {
				output.print("(");
				while (current != null) {
					++linecount;
					if (linecount > 400) {
						output.println("EXCEEDED MAXPRINT SETTING");
						return;
					}

					ActionName label = current.getEventPCA();

					output.print(label.getTypeString() + "<" + label.getProbability() + "> "
							+ label.getLabel() + " -> ");

					if (current.getNext() < 0)
						output.print("ERROR");
					else
						output.print("Q" + current.getNext());
					current = current.getList();
					if (current == null)
						if (i < pca.maxStates - 1)
							output.println("),");
						else
							output.println(").");
					else
						output.print("\n\t\t  |");
				}
			}
		}
	}

		/**
	 * resolve the Double type issue
	 * 
	 * @param pca
	 * @param digit
	 * @return
	 */
	public static CompactState getRoundProbPCA(CompactState pca, int digit) {
		for (int i = 0; i < pca.maxStates; ++i) {
			EventState current = pca.states[i];
			while (current != null) {
				ActionName label = current.getEventPCA();
				label.setProbability(GeneralUtil.round(label.getProbability(), digit));
				current = current.getList();
			}
		}
		return pca;
	}

	public CompactState getPcaObj() {
		return pcaObj;
	}

	public void setPcaObj(CompactState pcaObj) {
		this.pcaObj = pcaObj;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
